<?php

use Drupal\file\Entity\File;
use Drupal\views\Plugin\views\cache\CachePluginBase;
use Drupal\views\ViewExecutable;
/*
// JHU does not use group for access check based on field_access_terms.
use Drupal\taxonomy\Entity\Term;
*/

function idc_ui_module_theme($existing, $type, $theme, $path) {
  return [
    'header_left_template' => [
      'variables' => ['test_var' => NULL],
    ],
    'top_nav_template' => [
      'variables' => ['logged_in' => NULL],
    ],
    'footer_template' => [
      'variables' => [],
    ],
    'page--collections' => [
      'variables' => [
        'featured_collections' => NULL,
      ],
    ],
    'page--collection' => [
      'variables' => [
        'collection' => NULL,
        'featured_items' => NULL,
        'primary_description' => NULL,
        'citable_url' => NULL,
      ],
    ],
    'page--item' => [
      'variables' => [
        'item' => NULL,
      ],
    ],
    'page--search' => [
      'variables' => []
    ],
    'idc_search_template' => [
      'variables' => []
    ],
    'page--advanced-search' => [
      'variables' => []
    ]
  ];
}

use Symfony\Component\HttpFoundation\RedirectResponse;

function idc_ui_module_file_download($uri) {
  $MEDIA_TYPES = array(
    (object) [
      'type' => 'image',
      'source_field' => 'field_media_image',
    ],
    (object) [
      'type' => 'file',
      'source_field' => 'field_media_file',
    ],
    (object) [
      'type' => 'document',
      'source_field' => 'field_media_document',
    ],
    (object) [
      'type' => 'audio',
      'source_field' => 'field_media_audio_file',
    ],
    (object) [
      'type' => 'video',
      'source_field' => 'field_media_video_file',
    ],
    (object) [
      'type' => 'extracted_text',
      'source_field' => 'field_media_file',
    ],
    (object) [
      'type' => 'fits_technical_metadata',
      'source_field' => 'field_media_file',
    ],
  );


  $files = File::loadMultiple(array(), array(
    'uri' => $uri,
  ));

  if (count($files)) {
    foreach ($files as $item) {
      if ($item->uri === $uri) {
        $file = $item;
        break;
      }
    }
  }

  $file = \Drupal::entityTypeManager()
  ->getStorage('file')
  ->loadByProperties([
    'status' => 1,
    'uri' => $uri,
  ]);

  if($file) {
    $current_user = \Drupal::currentUser();
    $authorized_roles = ['administrator', 'collection_level_admin', 'global_admin'];
    $is_authorized = !!count(array_intersect($authorized_roles, array_values($current_user->getRoles())));

    # authorize access if user is special user #1, which Drupal treats as a kind of admin
    if (!$is_authorized) {
      $is_authorized = $current_user->id() == "1";
    }

    foreach ($MEDIA_TYPES as &$media_type_obj) {
      $media = \Drupal::entityTypeManager()
      ->getStorage('media')
      ->loadByProperties([
        'status' => 1,
        $media_type_obj->source_field => array_values($file)[0]->id(),
      ]);

      if (isset(array_values($media)[0]) && array_values($media)[0]->get('field_restricted_access')->getString() == "1" && !$is_authorized) {
        return -1;
      }
    }
  }

  return;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function idc_ui_module_form_views_exposed_form_alter(&$form, $form_state) {
  // XXX: Exposed filters with REST appear to still render a form even though
  // it technically does not use one.
  if ($form['#action'] === "/search_rest_endpoint") {
    // Set the limit to be close to the lower bound URL parameter limit.
    $form['query']['#maxlength'] = 65536;
  }
}

/**
 * Implements hook_views_post_render().
 */
function idc_ui_module_views_post_render(ViewExecutable $view, &$output, CachePluginBase $cache) {
  // XXX: Cache max-age 0 isn't able to be utlized by anonymous users.
  // Similarly, a Serializer's cacheable metadata does not get bubbled up to the
  // view and thus we are stuck with setting our own cache tags. In the event
  // indexing more than just content (nodes) gets done this should be updated
  // to include those tags as well.
  // @see: https://www.drupal.org/docs/drupal-apis/cache-api/cache-max-age
  // @see: https://www.drupal.org/project/drupal/issues/3210146
  // @see: https://www.drupal.org/project/facets/issues/2939710
  if ($view->id() === 'solr_search_content') {
    $output['#cache']['tags'][] = 'node_list';
  }
}

/**
 * Implements hook_form_FORM_ID_alter()
 * Modify Repository Item Contact Form to the item's title to the subject
 */
function idc_ui_module_form_contact_message_repository_item_contact_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $node = \Drupal::routeMatch()->getParameter('node');

  if (!empty($node)) {
    $form['subject']['widget'][0]['value']['#default_value'] = $node->getTitle() . ' (' . $node->id() . ')';
  }
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * @param $variables
 */
function idc_ui_module_preprocess_status_messages(&$variables) {
  if(isset($variables['message_list']['status'])){
    $status_messages = $variables['message_list']['status'];
    foreach($status_messages as $delta => $message) {
      if (strpos((string) $message->jsonSerialize(), 'Export complete') !== FALSE) {
        $variables['message_list']['status'][$delta] = Drupal\Core\Render\Markup::create(str_replace('http', 'https', $message->jsonSerialize()));
      }
    }
  }
}

/**
 * Implements hook_media_insert().
 */
function idc_ui_module_media_insert($media) {
  if ($media->bundle() != 'extracted_text') {
    return;
  }

  reindexGrandParent($media);
}

/**
 * Implements hook_media_update().
 */
function idc_ui_module_media_update($media) {
  if ($media->bundle() != 'extracted_text') {
    return;
  }

  reindexGrandParent($media);
}


/**
 * Reindexes parent node for a media. No-op if parent does not exist.
 *
 * @param Media whose parent you want to reindex.
 */
function reindexGrandParent($media) {
  if (!$media->hasField('field_media_of')) {
    return NULL;
  }
  $field = $media->get('field_media_of');
  if ($field->isEmpty()) {
    return NULL;
  }
  $parent = $field->first()
    ->get('entity')
    ->getTarget();

  if ($parent === NULL) {
    return NULL;
  }
  $parent = $parent->getValue();

  $model_references = $parent->get('field_model')->referencedEntities();

  if ($model_references) {
    $model_type = $model_references[0]->get('name')->getString();
  }

  if ($model_type != 'Page') {
    return NULL;
  }

  if (!$parent->hasField('field_member_of')) {
    return NULL;
  }
  $field = $parent->get('field_member_of');
  if ($field->isEmpty()) {
    return NULL;
  }
  $grand_parent = $field->first()
    ->get('entity')
    ->getTarget();

  if ($grand_parent === NULL) {
    return;
  }
  $grand_parent = $grand_parent->getValue();

  $grand_parent->original = $grand_parent;
  search_api_entity_update($grand_parent);
}

/**
 * Lets modules alter the Solarium select query before executing it.
 *
 * After this hook, the select query will be finally converted into an
 * expression that will be processed by the lucene query parser. Therefore you
 * can't modify the 'q' parameter here, because it gets overwritten by that
 * conversion. If you need to modify the 'q' parameter you should implement an
 * event listener instead of this hook that handles the solarium events (our
 * connector injects the drupal event handler into solarium) or implement
 * hook_search_api_solr_converted_query() instead. If you want to force a
 * different parser like edismax you must set the 'defType' parameter
 * accordingly.
 *
 * @param \Solarium\Core\Query\QueryInterface $solarium_query
 *   The Solarium query object, as generated from the Search API query.
 * @param \Drupal\search_api\Query\QueryInterface $query
 *   The Search API query object representing the executed search query.
 */
function idc_ui_module_search_api_solr_query_alter(\Solarium\Core\Query\QueryInterface $solarium_query, \Drupal\search_api\Query\QueryInterface $query) {
  $search = array_key_exists('query', $_GET) ? $_GET['query'] : "";
  \Drupal::logger('idc_ui_module')->info("search = " . $search);
  if (strstr($search, "*")) {
    \Drupal::logger('idc_ui_module')->info("search contains wildcard = " . $search);
    $queryfields = $solarium_query->getEDisMax()->getQueryFields();
    \Drupal::logger('idc_ui_module')->info("queryfields = <pre>" . print_r($queryfields, true) . '</pre>');
    $custom_query = idc_ui_module_build_solr_query($search, $queryfields);
    $solarium_query->setQuery('');
    $solarium_query->addParam('q.alt', $custom_query);
    $solarium_query->addParam("qt", "edismax");
    $solarium_query->addParam('defType', 'edismax');
    /*
    // JHU does not use group or index the content type
    $access_filter = ''; // 'ss_type:"islandoraobject"'; // idc_ui_module_get_account_access_filter();
    // \Drupal::logger('idc_ui_module')->info('$access_filter = ' . $access_filter);
    $solarium_query->addParam('fq', $access_filter);
    */
  }
  else {
    \Drupal::logger('idc_ui_module')->info("search does not contain wildcard = " . $search);
  }
}

/**
 * Build the Solr query based on the $search.
 *
 * $queryfields will be something like this:
 *   "tm_X3b_en_description^1 tm_X3b_und_description^1 tm_X3b_en_field_corp_alt_name^1 ..."
 */
function idc_ui_module_build_solr_query(string $search, string $queryfields) {
  // strip off parenthesis from the search
  $logical_operators = ['AND', 'NOT', 'OR'];
  $parentheses = [')', '('];
  $search = idc_ui_module_adjust_for_midwildcards($search);
  \Drupal::logger('idc_ui_module')->info("search adjusted to address mid-string wildcards = " . $search);  
  $search = idc_ui_module_remove_stopwords($search);
  /*
  NOTE: if not provided by the user search, the "AND" and parentheses must be added.
  User searched for "Resource Brochure"~45 AND "File copyright"~46 NOT "Legion Headquarters"~20
  For proximity search, the resultant query fields logic must look like this.

    User search: "Resource Brochure"~45 AND "File copyright"~46 NOT "Legion Headquarters"~20
    q.alt = (tm_X3b_en_rendered_item:"Resource Brochure"~45)
      AND (tm_X3b_en_rendered_item:"File copyright"~46)
      NOT (tm_X3b_en_rendered_item:"Legion Headquarters"~20)

    User search: "Resource Brochure"~45 NOT John
    q.alt = (tm_X3b_en_rendered_item:"Resource Brochure"~45) NOT (tm_X3b_en_rendered_item:*John*)

    User search: "Resource Brochure"~45 AND "File copyright"~46 NOT "Education John"~10
    q.alt = tm_X3b_en_rendered_item:"Resource Brochure"~45 AND tm_X3b_en_rendered_item:"File copyright"~46 NOT tm_X3b_en_rendered_item:"Education John"~10
  */

  $removed_searchterms = idc_ui_module_remove_badlength_searchterms($search);
  $search = str_replace(['(', ')', ' '], ['bcs_lparenthesis', 'bcs_rparenthesis', '_bcs_sp_l _bcs_sp_r'], $search);
  $search = idc_ui_module_quoted_strings($search, TRUE);
  $initial_search = $search = idc_ui_module_removespaces_quoted_strings($search, ' ', '+');
  \Drupal::logger('idc_ui_module')->info('b initial_search = ' . $initial_search);

  // Does the provided query use any of the logic operators that are not in UPPERCASE?
  $tmp = ' ' . $search;
  // for this process, strip off any parentheses.
  $parts = explode(" ", str_replace($parentheses, '', $tmp));
  $has_operators = $has_non_uppercase_operator = FALSE;
  foreach ($parts as $part) {
    if ($part) {
      $part_nospecial = trim(str_replace(['bcs_lparenthesis', 'bcs_rparenthesis', '_bcs_sp_l' ,'_bcs_sp_r'], ['(', ')', ' ', ' '], $part));
      $upperpart = strtoupper($part_nospecial);
      $has_operators |= !(array_search($part_nospecial, $logical_operators) === FALSE);
      $has_non_uppercase_operator |= (!(array_search($upperpart, $logical_operators) === FALSE) &&
        ($part_nospecial <> $upperpart));
    }
  }
  if ($has_non_uppercase_operator) {
    \Drupal::messenger()->addMessage('All logical operators must be ALL-caps (like "AND", "NOT", "OR"). The search contained logical operators that were not in ALL-caps so they will be treated as ordinary search terms.', 'warning');
  }
  // Does the search string contain parenthesis, and are there the same number of open/close
  // parenthesis?
  if ((strstr($initial_search, "(") && (strstr($initial_search, ")"))) &&
    (strstr($initial_search, "(") <= (strstr($initial_search, "(")))) {
    $open_p = explode("(", $initial_search);
    $close_p = explode(")", $initial_search);
    if (count($open_p) != count($close_p)) {
      \Drupal::messenger()->addMessage('The number of left parenthesis does not match the number of right parenthesis. The query will remove all parentheses characters.', 'warning');
      $search = str_replace($parentheses, '', $search);
      $initial_search = $search;
      $has_parentheses = FALSE;
    }
    else {
      $has_parentheses = TRUE;
    }
  }
  \Drupal::logger('idc_ui_module')->info('removed_searchterms = ' . print_r($removed_searchterms, true));

  if ($search && count($removed_searchterms) > 0) {
    \Drupal::messenger()->addMessage('The search included at least one search term that is outside the required length between 2 and 100 characters. The remaining search does not include "' . implode('", "', $removed_searchterms) . '".', 'warning');
  }

  // Treat any set of terms as AND like "apples bananas cherries" would really be "apples AND bananas AND cherries"
  if (!$has_operators) {
    $search = $initial_search = str_replace(" ", " AND ", $initial_search);
  }

  // If the first word is NOT, add a space before it and the rebuilding of this below should handle the logic.
  if (substr($search, 0, 4) == 'NOT ') {
    $search = ' ' . $search;
  }
  if (strstr(strtoupper($search), ' _bcs_sp_rNOT_bcs_sp_l ')) {
    // Set all instances of " NOT " to uppercase.
    $search = str_replace(' _bcs_sp_rNOT_bcs_sp_l ', ' -', $search);
  }

  $search_parts = explode(" ", ltrim($search, ' '));
  $fields_parts = explode(" ", $queryfields);
  $solr_query = [];
  $last_logic_key = '';
  $logic = 'AND';
  foreach ($search_parts as $search_part) {
    $search_part_nospecial = trim(str_replace(['bcs_lparenthesis', 'bcs_rparenthesis', '_bcs_sp_l' ,'_bcs_sp_r'], ['(', ')', ' ', ' '], $search_part));
    // Remove any parentheses for correct key values in $replacements array.
    $replacements_key = str_replace(['(', ')'], '', $search_part_nospecial);
    foreach ($fields_parts as $field_part) {
      $field_part = str_replace('_und_', '_en_', $field_part);
      @list($fieldname, $boostweight) = explode("^", $field_part);

      if ($replacements_key) {
        $logic = ($replacements_key == 'OR') ? 'OR' : 'AND';
        if (($replacements_key <> 'AND') && ($replacements_key <> 'OR')) {
          if (substr($replacements_key, 0, 1) == '-') {
            $replacements_key = ltrim($replacements_key, '-');
            $logic = 'NOT';
          }
          $replacements_key = idc_ui_module_quoted_strings($replacements_key, FALSE);
          $replacements = $replacements_key; //str_replace(['_bcs_sp_l', '_bcs_sp_r'], '', $replacements_key);
          // If this is NOT a quoted string or proximity search, we have to wrap with double quotes.
          if (!(strstr($replacements, '~')) && !(strstr($replacements, '*')) && !(strstr($replacements, '"'))) {
            $replacements = '"' . $replacements . '"';
          }

          if ($last_logic_key == '') { $last_logic_key = $logic; }
          if (strstr($replacements, '*')) {
            // Split into two parts
            $query_wildcard_parts = explode("*", $replacements);
            if (count($query_wildcard_parts) > 2) {
              \Drupal::messenger()->addMessage('All logical operators must be ALL-caps (like "AND", "NOT", "OR"). The search term contained more than one wildcard.', 'warning');
              $solr_query[$replacements][$last_logic_key][] = $fieldname . ':' . $replacements . ($boostweight ? '^' . $boostweight : '');
            }
            else {
              $solr_query[$replacements][$last_logic_key][] = $fieldname . ':' . $replacements . ($boostweight ? '^' . $boostweight : '');
            }
          }
          else {
            $solr_query[$replacements][$last_logic_key][] = $fieldname . ':' . $replacements . ($boostweight ? '^' . $boostweight : '');
          }
        }
      }
    }
    $last_logic_key = $logic;
  }
  \Drupal::logger('c')->info('solr_query(pre-split) = <pre>' . print_r($solr_query, true) . '</pre>');
  $replacements = [];
  foreach ($solr_query as $search_part => $logic_conditions) {
    // Remove any parentheses for correct key values in $replacements array.
    $replacements_key = str_replace(['(', ')'], '', $search_part);
    if (array_search($replacements_key, $logical_operators) === FALSE) {
      foreach ($logic_conditions as $logic => $conditions) {
        $condition_str = implode(" ", $conditions);
        $condition_str = str_replace(['bcs_lparenthesis', 'bcs_rparenthesis', '_bcs_sp_l', '_bcs_sp_r'], ['(', ')', '', ''], $condition_str);
        if ($logic == 'AND' || $logic == 'OR') {
          $replacements[$replacements_key] = '(' . $condition_str . ')';
        }
        elseif ($logic == 'NOT') {
          $replacements[$replacements_key] = '-(' . $condition_str . ')';
        }
        \Drupal::logger('c')->info('replacements_key = ' . $replacements_key . ', replacements[$replacements_key] =<pre>' . print_r($replacements[$replacements_key], true) . '</pre>');

      }
    }
  }
  \Drupal::logger('c')->info('$replacements =<pre>' . print_r($replacements, true) . '</pre>');
  \Drupal::logger('idc_ui_module')->info('c initial_search = ' . $initial_search);
  // Reset the $initial_search variable, so that the build of the query matches the token-fields to replace.
  $initial_search = idc_ui_module_quoted_strings($initial_search, FALSE);
  \Drupal::logger('idc_ui_module')->info('d initial_search = ' . $initial_search);

  // Remove the special characters and operators from the initial query and
  // use that string as the token-replace for the above generated $replacements.
  $solr_query_str = str_replace(
    ['NOT ', /* '*',*/ '_bcs_sp_l AND _bcs_sp_r',
      '"bcs_rparenthesis_bcs_sp_l _bcs_sp_rAND_bcs_sp_l _bcs_sp_rbcs_lparenthesis',
      '_bcs_sp_l _bcs_sp_rAND_bcs_sp_l _bcs_sp_r',
      '"_bcs_sp_l _bcs_sp_rOR_bcs_sp_l _bcs_sp_r',
      '_bcs_sp_l _bcs_sp_rOR_bcs_sp_l _bcs_sp_r',
      '"_bcs_sp_l _bcs_sp_rNOT_bcs_sp_l _bcs_sp_r',
      '_bcs_sp_l _bcs_sp_rNOT_bcs_sp_l _bcs_sp_r',
      'bcs_lparenthesis', 'bcs_rparenthesis', ' OR "'
    ],
    ['-', /* '',*/ ' AND ', ' AND ', ' AND ', ' OR ', ' OR ', ' -', ' -', '(', ')', ' OR '],
    $initial_search);
  \Drupal::logger('idc_ui_module')->info('solr_query_str = ' . $solr_query_str);

  foreach ($replacements as $search_part => $replacement) {
    // Special handling for quoted strings.
    if (!(strstr($search_part, '~'))) {
      // ONLY do this if the part contains two double-quotes and trailing is not "_bcs_sp_l"
      $num_quotes = substr_count($search_part, '"');
      $trailing_9 = substr($search_part, strlen($search_part) - 9);
      if ($num_quotes == 2 && $trailing_9 <> '_bcs_sp_l') {
        $search_part = str_replace('"', '', $search_part);
      }
    }
    $term = $search_part; //str_replace("*", "", $search_part);
    if (array_search($term, $logical_operators) === FALSE) {
      \Drupal::logger('idc_ui_module')->info('term = ' . $term);
      $solr_query_str = str_replace($term, $replacement, $solr_query_str);
    }
  }

  // Remove the "+" from the quoted strings so that the query comes out ok.
  $solr_query_str = idc_ui_module_removespaces_quoted_strings($solr_query_str, '+', ' ');
  // Bit of a hack, but when the entire initial search was double-quoted, fix the $solr_query_str.
  $first_two_char = substr($solr_query_str, 0, 2);
  $last_two_char = substr($solr_query_str, strlen($solr_query_str) - 2, 2);
  if ($first_two_char == '"(' && $last_two_char == ')"') {
    $solr_query_str = rtrim(ltrim($solr_query_str, '"'), '"');
  }
  if ($solr_query_str == '') { $solr_query_str = '*:*'; }
  \Drupal::logger('idc_ui_module')->info('solr query = ' . $solr_query_str);
  return $solr_query_str;
}

function idc_ui_module_quoted_strings($search, $solidify = TRUE) {
  if ($solidify) {
    preg_match_all('/"([^"]+)"/', $search, $m);
    foreach ($m[0] as $quoted_string) {
      $replace_with = str_replace([" ", '"'], ["_bcs_quote_sp_", "_bcs_dquote_"], $quoted_string);
      $search = str_replace($quoted_string, $replace_with, $search);
    }
  }
  else {
    $search = str_replace(["_bcs_quote_sp_", "_bcs_dquote_"], [" ", '"'], $search);

  }
  return $search;
}

/**
 * Helper function to split a search into condition terms - especially
 * regarding when a wildcard is mid-string.
 */
function idc_ui_module_adjust_for_midwildcards($search) {
  $quote = '"';
  $search = ltrim(rtrim($search, ')'), '(');
  $terms = [];
  $tmp_terms = explode(" ", $search);
  foreach ($tmp_terms as $tmp_term) {
    // If the wildcard character is mid-string, split that into
    // two conditions like "prefix*suffix" becomes both "prefix*" and
    // "*suffix".
    \Drupal::logger('idc_ui_module')->info("tmp_term <pre>" . $tmp_term . '</pre>');
    if (strstr($tmp_term, "*")) {
      $tmp_term = ltrim(rtrim($tmp_term, "*"), "*");
      \Drupal::logger('idc_ui_module')->info("tmp_term no end/lead * <pre>" . $tmp_term . '</pre>');
      $term_parts = explode("*", $tmp_term);
      \Drupal::logger('idc_ui_module')->info("term_parts = <pre>" . print_r($term_parts, true) . '</pre>');
      
      if (count($term_parts) == 2) {
        $terms[] = $quote . $term_parts[0] . '*' . $quote;
        $terms[] = $quote . '*' . $term_parts[1] . $quote;
      }
    }
    else {
      $terms[] = $quote . $tmp_term . $quote;
    }
  }
  return '(' . implode(' AND ', $terms) . ')';
} 

// JHU does not use groups for access control.
/*
function idc_ui_module_get_account_access_filter() {
  $current_user = \Drupal::currentUser();
  $account = \Drupal\user\Entity\User::load($current_user->id());
  $account_roles = $account->getRoles();
  $super_user = ($account->isAuthenticated() && (in_array("administrator", $account_roles)));
  // Start off with the filter that we need...
  $conditions = ['ss_type:"islandoraobject"'];
  if (!$super_user) {
    $permission_checker = \Drupal::service('group_permission.checker');
    foreach ($account_roles as $account_role) {
      \Drupal::logger('idc_ui_module')->info('ROLE: ' . $account_role);
    }

    // for each access term, get the term, get the group, check the access -- if it is false then it should be constrained from the query.
    $terms = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadTree('islandora_access');
    foreach ($terms as $term) {
      // Get the group corresponding to the term name -- like "Admin-only access"
      $group_results = \Drupal::entityTypeManager()->getStorage('group')->loadByProperties(['label' => $term->name]);
      if (is_null($group_results)) {
        \Drupal::logger('idc_ui_module')->info('NULL group loaded by "' . $term->name . '"');
      }
      else {
        \Drupal::logger('idc_ui_module')->info("conditions = <pre>(" . implode(" AND ", $conditions) . ')</pre>');
        $group = reset($group_results);
        $can_view = $permission_checker->hasPermissionInGroup('view group_node:islandora_object entity', $current_user, $group);
        if (!$can_view) {
          $conditions[] = '!itm_field_access_terms:' . $term->tid;
        }
      }
    }
  }
  \Drupal::logger('idc_ui_module')->info("conditions = <pre>(" . implode(" AND ", $conditions) . ')</pre>');
  return '(' . implode(" AND ", $conditions) . ')';
}
*/

// NOTE: The $search parameter is passed by reference and will be changed in this code if needed.
// The return value will be an array that includes any terms that were ignored.
//
// Helper function to remove any search terms that are outside of the required lenght as specified
// by the solr schema.xml as specified by the LengthFilterFactory min=2, max=100.c
function idc_ui_module_remove_badlength_searchterms(&$search) {
  $newparts = $removed_searchterms = [];
  $parts = explode(" ", $search);
  foreach ($parts as $part) {
    if ((strlen($part) < 2) || (strlen($part) > 100)) {
      $removed_searchterms[] = $part;
    }
    else {
      $newparts[] = $part;
    }
  }
  $search = implode(" ", $newparts);
  return $removed_searchterms;
}

function idc_ui_module_remove_stopwords($search) {
  // Get the stopwords from the config for the current language.
  $lang_code = \Drupal::languageManager()->getCurrentLanguage()->getId();
  $url = '/solr/ISLANDORA/admin/file?wt=json&_=1655405421219&file=stopwords_' .
    $lang_code . '.txt&contentType=text%2Fplain%3Bcharset%3Dutf-8';
  // Use Guzzle HTTP client to pull in that file.
  try {
    $response = \Drupal::httpClient()->get('http://solr:8983'. $url, ['allow_redirects' => true]);
    $stopwords = $response->getBody();
    $stopwords = explode("
  ", $stopwords);
    }
  catch (ClientException $e) {
    // If there was a problem with the call to get the current Solr config
    // stopwords for the users' language code, provide defaults values.
    $stopwords = ["a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or", "s", "such", "t", "that", "the", "their", "then", "there", "these", "they", "this", "to", "was", "will", "with"];
  }
  // Either way, allow the logical operators if they are used.
  $keepwords = ['and', 'not', 'or'];
  foreach ($keepwords as $keepword) {
    $at = array_search($keepword, $stopwords);
    if (!($at === FALSE)) {
      unset($stopwords[$at]);
    }
  }  
  $temp = idc_ui_module_quoted_strings($search);
  $parts = explode(" ", $temp);
  $newparts = [];
  foreach ($parts as $part) {
    $solidified_part = idc_ui_module_quoted_strings($part, TRUE);
    // Skip if the terms are quoted strings.
    if (!strstr($part, "_bcs_quote_sp_")) {
      $textonly_part = strtolower(preg_replace( '/[\W]/', '', $solidified_part));
      if (array_search($textonly_part, $stopwords) === FALSE) {
        $newparts[] = $solidified_part;
      }
    }
    else {
      // This is a solidified quoted value, so it can stay.
      $newparts[] = $solidified_part;
    }
  }
  return implode(" ", $newparts);
}

function idc_ui_module_removespaces_quoted_strings($search, $replace_char = ' ', $replace_with_char = '+') {
  if(preg_match_all("/[\"]{1}(.*?)[\"]{1}/im", $search, $matches)) {
    if (array_key_exists(1, $matches)) {
      foreach ($matches[1] as $match) {
        $replace_with = str_replace($replace_char, $replace_with_char, $match);
        $search = str_replace($match, $replace_with, $search);
      }
    }
  }
  // Fix a double negative which can occur when using a NOT at the beginning of a search.
  return str_replace('--', '*:* AND -', $search);
}
